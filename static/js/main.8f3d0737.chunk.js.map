{"version":3,"sources":["constants/types.js","actions/chart.js","components/Chart/index.js","selectors/charts.js","components/App/index.js","serviceWorker.js","reducers/charts.js","reducers/typeMap.js","reducers/index.js","sagas/charts.js","sagas/index.js","index.js"],"names":["REFRESH_CHARTS","REFRESH_CHARTS_OF_TYPE","REFRESH_CHARTS_VIA_TYPEMAP","DISPATCH_ACTION_AND_REFRESH","FETCH_NEW_DATA","RETICULATE_SPLINES","INITIALIZE_FLUX_CAPACITOR","nextChartID","chartTypes","setDate","id","date","type","payload","Chart","_this","this","chart","props","react_default","a","createElement","className","onChange","e","setName","target","value","name","setType","PureComponent","connect","getSortedCharts","createSelector","state","charts","Object","values","sort","b","App","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","createChart","bind","assertThisInitialized","refreshCharts","refreshTypeACharts","refreshTypeBCharts","refreshStaleCharts","refreshChartsOfType","refreshChartsViaTypeMap","dispatchActionAndRefresh","Date","now","onClick","map","components_Chart","key","Component","defaultProps","Math","floor","random","length","chartType","action","condition","Boolean","window","location","hostname","match","INITIAL","combineReducers","arguments","undefined","objectSpread","defineProperty","newState","_action$payload","_action$payload2","_action$payload3","console","log","typeMap","toConsumableArray","push","newType","keys","forEach","indexOf","filter","chartId","chartsSaga","refreshAllCharts","refreshChartsOfTypeUsingTypeMap","regenerator_default","wrap","_context","prev","next","all","takeEvery","stop","_marked","_arr","_i","_context2","select","sent","put","_marked2","_arr2","_i2","_context3","_marked3","chartIDs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_context4","Symbol","iterator","done","t0","return","finish","_marked4","wrappedAction","_wrappedAction$payloa","_arr3","_i3","_context5","_marked5","rootSaga","sagas_marked","__webpack_require__","d","__webpack_exports__","store","sagaMiddleware","createSagaMiddleware","applyMiddleware","createStore","createStoreWithMiddleware","reducers","__REDUX_DEVTOOLS_EXTENSION__","run","ReactDOM","render","es","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8f3d0737.chunk.js","sourcesContent":["export const CREATE_CHART                 = 'CREATE_CHART';\nexport const DELETE_CHART                 = 'DELETE_CHART';\n\nexport const REFRESH_CHARTS               = 'REFRESH_CHARTS';\nexport const REFRESH_CHARTS_OF_TYPE       = 'REFRESH_CHARTS_OF_TYPE';\nexport const REFRESH_CHARTS_VIA_TYPEMAP   = 'REFRESH_CHARTS_VIA_TYPEMAP';\n\nexport const DISPATCH_ACTION_AND_REFRESH  = 'DISPATCH_ACTION_AND_REFRESH';\n\nexport const SET_DATE                     = 'SET_DATE';\nexport const SET_TYPE                     = 'SET_TYPE';\nexport const SET_NAME                     = 'SET_NAME';\n\nexport const JUNK_ACTION                  = 'JUNK_ACTION';\nexport const FETCH_NEW_DATA               = 'FETCH_NEW_DATA';\nexport const RETICULATE_SPLINES           = 'RETICULATE_SPLINES';\nexport const INITIALIZE_FLUX_CAPACITOR    = 'INITIALIZE_FLUX_CAPACITOR';\n","import {\n  CREATE_CHART,\n  DELETE_CHART,\n\n  REFRESH_CHARTS,\n  REFRESH_CHARTS_OF_TYPE,\n  REFRESH_CHARTS_VIA_TYPEMAP,\n\n  DISPATCH_ACTION_AND_REFRESH,\n\n  SET_DATE,\n  SET_TYPE,\n  SET_NAME,\n\n  JUNK_ACTION,\n} from '../constants/types';\n\nlet nextChartID = 0;\n\nconst chartTypes = ['Type A', 'Type B', 'Type C', 'Type D', 'Type E', 'Type F'];\n\nexport const createChart = () => {\n  const id = nextChartID++;\n  return {\n    type : CREATE_CHART,\n    payload : {\n              id,\n              name : 'New chart',\n              type : chartTypes[ Math.floor(Math.random() * chartTypes.length) ],\n              date : Date.now(),\n            }\n  }\n};\n\nexport const deleteChart = () => {\n  return {\n    type : DELETE_CHART\n  }\n};\n\nexport const refreshCharts = () => {\n  return {\n    type : REFRESH_CHARTS\n  }\n};\n\nexport const refreshChartsViaTypeMap = (chartType) => {\n  return {\n    type    : REFRESH_CHARTS_VIA_TYPEMAP,\n    payload : { chartType }\n  }\n};\n\nexport const refreshChartsOfType = (chartType) => {\n  return {\n    type    : REFRESH_CHARTS_OF_TYPE,\n    payload : { chartType }\n  }\n};\n\n\nexport const dispatchActionAndRefresh = (action, condition) => {\n  return {\n    type    : DISPATCH_ACTION_AND_REFRESH,\n    payload : { action, condition }\n  }\n}\n\nexport const setDate = (id, date) => {\n  return {\n    type    : SET_DATE,\n    payload : {id, date}\n  }\n};\n\nexport const setType = (id, type) => {\n  return {\n    type    : SET_TYPE,\n    payload : {id, type}\n  }\n};\n\nexport const setName = (id, name) => {\n  return {\n    type    : SET_NAME,\n    payload : {id, name}\n  }\n};\n\nexport const junkAction = (name, type) => {\n  return {\n    type : JUNK_ACTION,\n    payload : { name, type }\n  }\n};\n","import React, { PureComponent } from 'react';\nimport { connect } from 'react-redux';\n\nimport './Chart.css';\n\nimport { setName, setType, setDate } from '../../actions';\n\nclass Chart extends PureComponent {\n\n  render() {\n\n    const chart = this.props.chart;\n\n    return (\n      <div className='chart'>\n        <div className='field'>ID</div>\n        <div className='value'>{chart.id}</div>\n\n        <div className='field'>Name</div>\n        <div className='value'>\n          <input\n            type = 'text'\n            onChange={ e => this.props.setName(chart.id, e.target.value) }\n            value={chart.name} />\n        </div>\n\n        <div className='field'>Type</div>\n        <div className='value'>\n          <input\n            type = 'text'\n            onChange={ e => this.props.setType(chart.id, e.target.value) }\n            value={chart.type} />\n        </div>\n\n        <div className='field'>Date</div>\n        <div className='value'>\n          <input\n            type = 'text'\n            onChange={ e => this.props.setDate(chart.id, e.target.value) }\n            value={chart.date} />\n        </div>\n      </div>\n    )\n  }\n}\n\n\nexport default connect( null, { setName, setType, setDate } )( Chart );\n","import { createSelector } from 'reselect';\n\nexport const getCharts  = state => state.charts;\n\nexport const getSortedCharts = createSelector(\n  [getCharts],\n  (charts) => {\n    return Object.values(charts).sort( (a,b) => a - b )\n  }\n)\n","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport './App.css';\n\nimport Chart from '../Chart';\n\nimport { createChart, refreshCharts, refreshChartsOfType, refreshChartsViaTypeMap, dispatchActionAndRefresh, junkAction } from '../../actions';\nimport { getSortedCharts } from '../../selectors';\n\nclass App extends Component {\n\n  static defaultProps = {\n    charts : []\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.createChart        = this.createChart.bind(this);\n    this.refreshCharts      = this.refreshCharts.bind(this);\n    this.refreshTypeACharts = this.refreshTypeACharts.bind(this);\n    this.refreshTypeBCharts = this.refreshTypeBCharts.bind(this);\n    this.refreshStaleCharts = this.refreshStaleCharts.bind(this);\n  }\n\n  createChart() {\n    this.props.createChart();\n  }\n\n  refreshCharts() {\n    this.props.refreshCharts();\n  }\n\n  refreshTypeACharts() {\n    this.props.refreshChartsOfType('Type A');\n  }\n\n  refreshTypeBCharts() {\n    this.props.refreshChartsViaTypeMap('Type B');\n  }\n\n  refreshStaleCharts() {\n    this.props.dispatchActionAndRefresh(\n      junkAction('junk', 'useless'),\n      (chart) => { return Date.now() - chart.date > 15 * 1000 }\n    )\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className='ui'>\n          <ul className='controls'>\n            <li><button onClick = { this.createChart } >Add chart</button></li>\n            <li><button onClick = { this.refreshCharts } >Refresh charts</button></li>\n            <li><button onClick = { this.refreshTypeACharts } >Refresh Type A charts</button></li>\n            <li><button onClick = { this.refreshTypeBCharts } >Refresh Type B charts, via type map</button></li>\n            <li><button onClick = { this.refreshStaleCharts } >Refresh charts that are 15 seconds old</button></li>\n          </ul>\n          <ul className='notes'>\n            <li>Okay. Start off by just clicking the 'Add chart' button a few times. That'll add some dummy \"chart\" widgets, which are\n            just boxes that have a few values. You can change them.\n            </li>\n            <li>The simplest case is just the 'Refresh charts' button. Click that, and everything refreshes.</li>\n            <li>Next simplest case would be the 'Refresh Type A charts' button. Click that, and only charts of Type A will refresh. Note\n            that chart types are randomly assigned upon creation, and you can edit the type of you don't have an \"Type A\" charts.</li>\n            <li>The slightly more complicated flavor is 'Refresh Type B charts, via type map'. This uses another key in the redux store, \"typeMap\".\n            That'll store a mapping from chart type to a list of chart IDs. This way we don't need to do a O(n) lookup across all charts to see if\n            they match, we'll have pre-computed and stored the matching charts. Obviously, this could be extended to use other chart attributes\n            as well.</li>\n            <li>The complex case is refreshing 15 second old charts. That one dispatches a different type of action that fires off some\n            arbitrary action (not specifically a REFRESH_CHART* type), and also takes a condition function that operates on each chart in the list\n            and refreshes it if it matches the condition. In this case, if it's more than 15 seconds old.</li>\n            <li>Since this is react, there's a ton of boilerplate and irrelevant stuff set up just to make the demo happen. You can really\n            just look at src/sagas/charts.js to see the saga implementation with notes on it. The rest is not documented and not written to OmniSci\n            style guidelines.</li>\n          </ul>\n        </div>\n        <div className='charts'>\n          { this.props.charts.map( chart => <Chart key={chart.id} chart={chart} /> ) }\n        </div>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    charts : getSortedCharts(state)\n  }\n}\n\nexport default connect( mapStateToProps, { createChart, refreshCharts, refreshChartsOfType, refreshChartsViaTypeMap, dispatchActionAndRefresh } )( App );\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import {\n  CREATE_CHART,\n  DELETE_CHART,\n\n  SET_DATE,\n  SET_TYPE,\n  SET_NAME,\n\n  JUNK_ACTION\n} from '../constants/types';\n\nconst INITIAL = {};\n\nexport default (state = INITIAL, action) => {\n  switch(action.type) {\n    case CREATE_CHART : {\n      const chart = action.payload;\n      return {\n        ...state,\n        [chart.id] : chart\n      }\n    }\n    case DELETE_CHART : {\n      const {id} = action.payload;\n      const newState = {...state};\n      delete newState[id];\n      return newState;\n    }\n    case SET_DATE : {\n      const { id, date } = action.payload;\n      const newState   = { ...state };\n      newState[id]     = { ...newState[id], date };\n      return newState;\n    }\n    case SET_TYPE : {\n      const { id, type } = action.payload;\n      const newState   = { ...state };\n      newState[id]     = { ...newState[id], type };\n      return newState;\n    }\n    case SET_NAME : {\n      const { id, name } = action.payload;\n      const newState   = { ...state };\n      newState[id]     = { ...newState[id], name };\n      return newState;\n    }\n    case JUNK_ACTION : {\n      console.log(\"A junk action was run. Nothing happens.\");\n      return state;\n    }\n    default :\n      return state;\n  }\n};\n","import {\n  CREATE_CHART,\n  SET_TYPE,\n} from '../constants/types';\n\nconst INITIAL = {};\n\nexport default (state = INITIAL, action) => {\n  switch(action.type) {\n    case CREATE_CHART : {\n      const chart = action.payload;\n\n      const newState = { ...state };\n\n      newState[chart.type] = newState[chart.type]\n        ? [ ...newState[chart.type] ]\n        : [];\n\n      newState[chart.type].push(chart.id)\n      return newState;\n\n    }\n    case SET_TYPE : {\n      const { id, type : newType } = action.payload;\n      const newState     = { ...state };\n\n      // first thing we need to do, tediously, is nuke the chart id from prior types.\n      // this could be faster, but the assumption is that chart types won't change.\n      // maybe we wouldn't even need to delete?\n      Object.keys(newState).forEach( type => {\n\n        if ( newState[type].indexOf(id) !== -1 ) {\n          newState[type] = newState[type].filter( chartId => chartId !== id );\n        }\n      });\n\n      newState[newType] = newState[newType]\n        ? [ ...newState[newType] ]\n        : [];\n\n      newState[newType].push(id);\n      return newState;\n    }\n    default :\n      return state;\n  }\n}\n","import { combineReducers } from 'redux';\n\nimport charts  from './charts';\nimport typeMap from './typeMap';\n\nexport default combineReducers({\n  charts,\n  typeMap\n});\n","import { all, put, takeEvery, select } from 'redux-saga/effects';\n\nimport {\n  REFRESH_CHARTS,\n  REFRESH_CHARTS_OF_TYPE,\n  REFRESH_CHARTS_VIA_TYPEMAP,\n  DISPATCH_ACTION_AND_REFRESH,\n  FETCH_NEW_DATA,\n  RETICULATE_SPLINES,\n  INITIALIZE_FLUX_CAPACITOR,\n} from '../constants/types';\n\nimport {\n  setDate,\n} from '../actions';\n\n/*\n  Okay, so here's where I'll try to explain my though process. First of all, the\n  action being \"REFRESH_CHARTS\" is arbitrary. Any action that'd cause all the charts\n  to refresh could go in here and call the refreshAllCharts function to call them all.\n  A couple of example alternative actions are provided here - as more get added, we just\n  add 'em into the yield all here.\n\n  Note that for demo purposes \"refreshing\" a chart just consists of setting its date to\n  NOW, whereas in actuality we'd want to do something more complicated.\n*/\n\nexport default function* chartsSaga() {\n  yield all([\n    takeEvery( REFRESH_CHARTS,              refreshAllCharts ),\n    takeEvery( FETCH_NEW_DATA,              refreshAllCharts ),\n    takeEvery( RETICULATE_SPLINES,          refreshAllCharts ),\n    takeEvery( INITIALIZE_FLUX_CAPACITOR,   refreshAllCharts ),\n    takeEvery( REFRESH_CHARTS_OF_TYPE,      refreshChartsOfType ),\n    takeEvery( REFRESH_CHARTS_VIA_TYPEMAP,  refreshChartsOfTypeUsingTypeMap ),\n    takeEvery( DISPATCH_ACTION_AND_REFRESH, dispatchActionAndRefresh )\n  ])\n}\n\n/* This function should hand most cases. I'd make an argument that if \"something\" happens\nthat should cause a refresh, we can just blast it out to all charts on the page, unless we\nhave a performance reason to limit it. Maybe we do? I dunno.\n\nBut as a starting point, I'd rather skew towards the less involved flavor.\n\n*/\n\nfunction* refreshAllCharts(action) {\n  const state = yield select();\n  const charts = state.charts;\n\n  for (const chart of Object.values(charts)) {\n    yield put( setDate( chart.id, Date.now() ) )\n  }\n}\n\n/* this one is barely slightly more complicated, and just arbitrarily. In this case,\nthe action takes a single value in its payload (\"chartType\" here, because of course a\nstandard redux action already has a \"type\" and I didn't want the two to get confused\nand we can't have nice things), and then behaves the same way except that it checks\nto see if the type matches whatever we're refreshing.\n\nNaturally \"type\" is arbitrary, and we could have different functions to refresh based on\ndifferent parameters. But if we're doing this for more than 1 or 2 fields, we'd probably\nwant to use a more generic approach.\n\n*/\n\nfunction* refreshChartsOfType(action) {\n  const { chartType } = action.payload;\n  const state = yield select();\n  const charts = state.charts;\n\n  for (const chart of Object.values(charts)) {\n    if ( chart.type === chartType ) {\n      yield put( setDate( chart.id, Date.now() ) )\n    }\n  }\n}\n\n/* This is the hyperdrive version of the above. The earlier method iterates over all of\nthe charts and does a comparison to see if they match the chart type (or whatever other key\nwe're using, in a different method). It's easy to implement, but it's relatively slow. Consider\nif we've got 100 charts on the page and need to look through the whole list just to see that 1\nor 2 charts need to be refreshed. It's not going to be brutally slow since it's just a loop and\nmost users probably wouldn't have a \"lot\" of charts on a page, but we're supposed to be high performance,\nright?\n\nSo this one uses an extra slice in the redux store that just maps type -> array of chart IDs (in this case),\nso when we come back in it can look up only the chart IDs that match the given type and iterate on them.\n\nMy assumption is that most of the time this isn't going to be worthwhile, since the difference between iterating\nover 10 charts and doing a simple conditional vs 3 charts and not checking anything is going to be trivial.\n\nBut 50 charts? 100? A more complicated condition? Then it could pay off.\n\nWe could also look into stuffing this into a selector of some sort if the conditional logic to see if a chart\nshould be refreshed is more complicated.\n\n*/\n\nfunction* refreshChartsOfTypeUsingTypeMap(action) {\n  const { chartType } = action.payload;\n  const state = yield select();\n  const { typeMap } = state;\n\n  const chartIDs = typeMap[chartType];\n\n  for (const id of chartIDs) {\n    yield put( setDate( id, Date.now() ) )\n  }\n}\n\n/* This is a very generic approach, and functionally very similar to the existing code.\n\nTo use this one, you'd dispatch an action of type DISPATCH_ACTION_AND_REFRESH, which\nhas an action and a condition in its payload. Yes, having an action have a payload with an\naction is confusing, I agree. Same issue as up above. Anyway, this saga will just immediately\ndispatch whatever action it was handed, and then iterate through the charts and check to see\nif they match the condition. If so, we refresh, and if not we skip it.\n\nOf course, we could also write a helper function to wrapper the original action creator so its\ninterface is unchanged. Maybe something like this, which I just dashed off and did not test:\n\nfunction makeRefreshableAction( actionCreator, condition = () => true ) {\n  return (...args) => {\n    dispatchActionAndRefresh(\n      actionCreator(...args),\n      condition\n    )\n  }\n}\n\nand then:\n\nconst refreshableActionCreator = makeRefreshableAction(actionCreator, condition);\n\nto get a drop in replacement for actionCreator. Assuming I dashed off the function properly, of course. :-)\n\nHonestly? I don't like this approach. It feels overly generic without a strong immediate need. On the other hand,\nit's very future proofed. It's also virtually the same as what we've already got. But hey, it's in a saga, so it's\na smidgen different.\n*/\n\nfunction* dispatchActionAndRefresh(wrappedAction) {\n  const { action, condition } = wrappedAction.payload;\n  yield put(action);\n  const state = yield select();\n  const charts = state.charts;\n\n  for (const chart of Object.values(charts)) {\n    if ( condition(chart) ) {\n      yield put( setDate( chart.id, Date.now() ) )\n    }\n  }\n}\n","import { all } from 'redux-saga/effects';\n\nimport chartsSaga from './charts';\n\nexport default function* rootSaga() {\n  yield all([\n    chartsSaga(),\n  ])\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nimport {Provider} from 'react-redux';\nimport {createStore, applyMiddleware} from 'redux';\nimport createSagaMiddleware from 'redux-saga';\n\nimport reducers from './reducers';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst createStoreWithMiddleware = applyMiddleware(sagaMiddleware)(createStore);\n\nexport const store = createStoreWithMiddleware(reducers, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n\nsagaMiddleware.run(rootSaga);\n\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>\n, document.getElementById('root'));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}